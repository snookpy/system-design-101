"use strict";(self.webpackChunksystem_design_101_docs=self.webpackChunksystem_design_101_docs||[]).push([[4586],{5830:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>s,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"async and concurrency/synchronization constructs","title":"Synchronization Constructs","description":"Synchronization constructs are mechanisms that help manage access to shared resources in a concurrent environment, ensuring that multiple threads or processes can operate safely without causing data corruption or inconsistencies.","source":"@site/docs/async and concurrency/synchronization constructs.md","sourceDirName":"async and concurrency","slug":"/async and concurrency/synchronization constructs","permalink":"/system-design-101/docs/async and concurrency/synchronization constructs","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Async Programming","permalink":"/system-design-101/docs/async and concurrency/async programming"},"next":{"title":"Messaging System","permalink":"/system-design-101/docs/messaging system/intro-message-system"}}');var a=t(4848),i=t(8453);const s={sidebar_position:2},o="Synchronization Constructs",c={},l=[{value:"Locks / Mutexes (Mutual Exclusion)",id:"locks--mutexes-mutual-exclusion",level:2},{value:"Read-Write Locks",id:"read-write-locks",level:2},{value:"Semaphore",id:"semaphore",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",mermaid:"mermaid",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"synchronization-constructs",children:"Synchronization Constructs"})}),"\n",(0,a.jsx)(n.p,{children:"Synchronization constructs are mechanisms that help manage access to shared resources in a concurrent environment, ensuring that multiple threads or processes can operate safely without causing data corruption or inconsistencies."}),"\n",(0,a.jsx)(n.h2,{id:"locks--mutexes-mutual-exclusion",children:"Locks / Mutexes (Mutual Exclusion)"}),"\n",(0,a.jsx)(n.p,{children:"Ensuring that only one thread can access a shared resource and keeping data safe and concurrent."}),"\n",(0,a.jsx)(n.p,{children:"We use two threads to increment the value of a counter. In one scenario, a mutex is employed to securely read and update the counter's value. In contrast, the second scenario omits the mutex, performing the same operations."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cs",children:'using System;\nusing System.Threading;\n\nclass Solution {\n    static int counter;\n    static readonly object lockObj = new object();\n\n    public static void RunExperiment(string experimentName, ThreadStart task) {\n        counter = 0;\n\n        Thread t1 = new Thread(task);\n        Thread t2 = new Thread(task);\n\n        t1.Start();\n        t2.Start();\n\n        t1.Join(); // Wait for the thread to complete\n        t2.Join();\n\n        Console.WriteLine($"Final counter value {experimentName}: {counter}\\n");\n    }\n\n    public static void IncrementCounterWithMutex() {\n        for (int i = 0; i < 100; i++) {\n            lock (lockObj) {\n                int temp = counter;\n                Thread.Sleep(1); // Sleep for 1 millisecond\n                counter = temp + 1;\n            }\n        }\n    }\n\n    public static void IncrementCounterNoMutex() {\n        for (int i = 0; i < 100; i++) {\n            int temp = counter;\n            Thread.Sleep(1); // Sleep for 1 millisecond\n            counter = temp + 1;\n        }\n    }\n}\n\nclass Program {\n    static void Main() {\n        Solution.RunExperiment("With Mutex Experiment", Solution.IncrementCounterWithMutex);\n        Solution.RunExperiment("No Mutex Experiment", Solution.IncrementCounterNoMutex);\n    }\n}\n\n//Results:\n//Final counter value With Mutex Experiment: 200\n//Final counter value No Mutex Experiment: 100\n'})}),"\n",(0,a.jsx)(n.h2,{id:"read-write-locks",children:"Read-Write Locks"}),"\n",(0,a.jsx)(n.p,{children:"Or Shared-Exclusive Locks or Reader-Writer Locks are synchronization primitives that allow concurrent read access to a shared resource but require exclusive access for write operations."}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Read Lock"}),": Multiple threads can hold read locks simultaneously, allowing concurrent read access to the shared resource. As read operations do not modify the resource, they can safely occur in parallel."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Write Locks"}),": Write lock is exclusive. Only one thread can hold a write lock at a time, ensure safe modification of the shared resource. When a thread holds a write lock, no other thread can acquire a read lock or a write lock, preventing concurrent access during write operation."]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"We interact with a shared variable, counter, that is accessed concurrently by multiple threads.We spawn 2 writer threads that increment the counter in a loop and 8 reader threads that continuously read its value. The program is designed to terminate once the counter reaches the TARGET_VALUE."}),"\n",(0,a.jsx)(n.p,{children:"Key principles to note in this scenario include:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Multiple threads can simultaneously read the value of the counter without blocking each other."}),"\n",(0,a.jsx)(n.li,{children:"A writer thread is restricted from updating the counter's value if either another writer is already performing an update, or if any readers are currently accessing the value."}),"\n",(0,a.jsx)(n.li,{children:"Similarly, a reader thread is prevented from accessing the counter if a writer thread is updating its value."}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cs",children:'using System;\nusing System.Collections.Generic;\nusing System.Threading;\n\nclass Program {\n    // Global shared resource\n    private static volatile int counter = 0;\n    // Shared mutex for synchronization\n    private static readonly ReaderWriterLockSlim mutex = new ReaderWriterLockSlim();\n    // We will increment counter until it reaches TARGET_VALUE\n    private const int TARGET_VALUE = 1000;\n\n    // Write operation - Use write lock\n    static int IncrementValue() {\n        mutex.EnterWriteLock();\n        try {\n            Thread.Sleep(1); // Sleep for 1 millisecond\n            if (counter < TARGET_VALUE) {\n                ++counter;\n            }\n        } finally {\n            mutex.ExitWriteLock();\n        }\n        return counter;\n    }\n\n    // Read operation - Use shared lock\n    static int ReadValue() {\n        mutex.EnterReadLock();\n        try {\n            Thread.Sleep(1); // Sleep for 1 millisecond\n            return counter;\n        } finally {\n            mutex.ExitReadLock();\n        }\n    }\n\n    static void Reader() {\n        while (ReadValue() < TARGET_VALUE) {\n            Thread.Sleep(1); // Sleep for 1 millisecond\n        }\n    }\n\n    static void Writer() {\n        while (IncrementValue() < TARGET_VALUE) {\n            Thread.Sleep(1); // Sleep for 1 millisecond\n        }\n    }\n\n    static void Main(string[] args) {\n        var start = DateTime.Now;\n\n        var readers = new List<Thread>();\n        for (int i = 0; i < 8; ++i) { // 8 reader threads\n            readers.Add(new Thread(Reader));\n        }\n\n        var writers = new List<Thread>();\n        for (int i = 0; i < 2; ++i) { // 2 writer threads\n            writers.Add(new Thread(Writer));\n        }\n\n        foreach (var reader in readers) {\n            reader.Start();\n        }\n\n        foreach (var writer in writers) {\n            writer.Start();\n        }\n\n        foreach (var reader in readers) {\n            reader.Join();\n        }\n\n        foreach (var writer in writers) {\n            writer.Join();\n        }\n\n        var end = DateTime.Now;\n        TimeSpan duration = end - start;\n        Console.WriteLine("Time taken: " + duration.TotalSeconds + " seconds");\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"semaphore",children:"Semaphore"}),"\n",(0,a.jsx)(n.p,{children:"Semaphores are synchronization primitives that control access to shared resources, maintaining an integer value to manage permits. They permit multiple threads to access a shared resource, but only up to a predetermined number of permits, ensuring smooth concurrency control in various synchronization contexts."}),"\n",(0,a.jsx)(n.p,{children:"Types of Semaphores"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Binary Semaphore (Mutex): Utilized for managing access to a single resource, it operates with two states, 0 and 1, ensuring mutual exclusion in critical sections."}),"\n",(0,a.jsx)(n.li,{children:"Counting Semaphore: Manages access to multiple resource instances, capable of holding values greater than 1. It limits the number of simultaneous accesses to a resource."}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Example shared variable named counter, we create 6 threads for this task. Each thread works to increase the counter value, but only 2 threads are allowed to do this at the same time. This limit of 2 is set by a semaphore."}),"\n",(0,a.jsx)(n.mermaid,{value:"sequenceDiagram\n    autonumber\n    participant T1 as Thread 1\n    participant T2 as Thread 2\n    participant T3 as Thread 3\n    participant T4 as Thread 4\n    participant T5 as Thread 5\n    participant T6 as Thread 6\n    participant Slot1 as Semaphore Slot 1\n    participant Slot2 as Semaphore Slot 2\n    participant Counter as Shared Counter\n\n    Note over T1,T6: 2 slots available, max 2 threads concurrently\n\n    %% Initial threads acquire slots\n    T1->>Slot1: WaitOne\n    T2->>Slot2: WaitOne\n\n    %% Threads increment counter\n    Slot1->>Counter: Interlocked.Increment\n    Slot2->>Counter: Interlocked.Increment\n\n    %% Remaining threads wait\n    T3->>Slot1: WaitOne (waiting)\n    T4->>Slot2: WaitOne (waiting)\n    T5->>Slot1: WaitOne (waiting)\n    T6->>Slot2: WaitOne (waiting)\n\n    %% Threads release slots and next thread enters\n    Slot1->>T3: Release\n    T3->>Counter: Interlocked.Increment\n\n    Slot2->>T4: Release\n    T4->>Counter: Interlocked.Increment\n\n    Slot1->>T5: Release\n    T5->>Counter: Interlocked.Increment\n\n    Slot2->>T6: Release\n    T6->>Counter: Interlocked.Increment"}),"\n",(0,a.jsx)(n.p,{children:"Demo code will use 10 threads, 5 slots, and a semaphore to control access to the shared counter variable. The goal is for the counter to reach 5000."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cs",children:'using System;\nusing System.Threading;\nusing System.Diagnostics;\n\nclass SemaphoreExample {\n    // Global shared resource\n    // Interlocked operations are used to perform atomic operations on \'counter\'\n    private static int counter = 0;\n\n    // Semaphore with a count of 5\n    private static readonly Semaphore semaphore = new Semaphore(5, 5);\n\n    private const int TARGET_VALUE = 5000;\n\n    static void Worker() {\n        while (true) {\n            semaphore.WaitOne(); // Acquire the semaphore\n            if (counter >= TARGET_VALUE) {\n                semaphore.Release(); // Release the semaphore\n                break;\n            }\n            Interlocked.Increment(ref counter); // Atomically increments the counter\n            Thread.Sleep(1); // Simulate work\n            semaphore.Release(); // Release the semaphore\n        }\n    }\n\n    static void Main() {\n        Stopwatch stopwatch = Stopwatch.StartNew();\n\n        Thread[] workers = new Thread[10];\n        for (int i = 0; i < workers.Length; i++) {\n            workers[i] = new Thread(Worker);\n            workers[i].Start();\n        }\n\n        foreach (Thread worker in workers) {\n            worker.Join();\n        }\n\n        stopwatch.Stop();\n        Console.WriteLine("Time taken: " + stopwatch.Elapsed.TotalSeconds + " seconds");\n    }\n}\n'})})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>o});var r=t(6540);const a={},i=r.createContext(a);function s(e){const n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);
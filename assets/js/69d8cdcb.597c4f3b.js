"use strict";(self.webpackChunksystem_design_101_docs=self.webpackChunksystem_design_101_docs||[]).push([[4970],{1323:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"OOD/solid","title":"SOLID","description":"Guide for helping developers create better-structured, more manageable object-oriented programming (OOP) code.","source":"@site/docs/OOD/solid.md","sourceDirName":"OOD","slug":"/OOD/solid","permalink":"/system-design-101/docs/OOD/solid","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Security","permalink":"/system-design-101/docs/security/"},"next":{"title":"Concurrency","permalink":"/system-design-101/docs/async and concurrency/concurrency"}}');var t=i(4848),o=i(8453);const r={},a="SOLID",l={},c=[{value:"Single Responsibility Principle (SRP)",id:"single-responsibility-principle-srp",level:2},{value:"Cohesion",id:"cohesion",level:3},{value:"Coupling",id:"coupling",level:3},{value:"High Coupling in Code: One Class Doing Too Much",id:"high-coupling-in-code-one-class-doing-too-much",level:4},{value:"Reducing Coupling: Separate Database Logic from Student Class",id:"reducing-coupling-separate-database-logic-from-student-class",level:4},{value:"Separation of Concerns",id:"separation-of-concerns",level:3},{value:"Example of Separation of Concerns",id:"example-of-separation-of-concerns",level:4},{value:"Single Responsibility Principle (SRP) vs. Coupling",id:"single-responsibility-principle-srp-vs-coupling",level:3},{value:"Single Responsibility Principle (SRP) vs. Cohesion",id:"single-responsibility-principle-srp-vs-cohesion",level:3},{value:"Single Responsibility Principle vs. Separation of Concerns (SoC)",id:"single-responsibility-principle-vs-separation-of-concerns-soc",level:3},{value:"The Open/Closed Principle (OCP)",id:"the-openclosed-principle-ocp",level:2},{value:"Code without OCP",id:"code-without-ocp",level:3},{value:"<strong>Refactoring the Code to Follow OCP</strong>",id:"refactoring-the-code-to-follow-ocp",level:3},{value:"Caution When Applying OCP",id:"caution-when-applying-ocp",level:3},{value:"The Liskov Substitution Principle (LSP)",id:"the-liskov-substitution-principle-lsp",level:2},{value:"Example Violates LSP",id:"example-violates-lsp",level:3},{value:"Refactoring to Follow LSP",id:"refactoring-to-follow-lsp",level:3},{value:"Composition",id:"composition",level:3},{value:"Problem with Inheritance (Violating LSP)",id:"problem-with-inheritance-violating-lsp",level:4},{value:"Using Composition to Follow LSP",id:"using-composition-to-follow-lsp",level:4},{value:"The Interface Segregation Principle (ISP)",id:"the-interface-segregation-principle-isp",level:2},{value:"Example Violates ISP",id:"example-violates-isp",level:3},{value:"Refactoring to Follow ISP",id:"refactoring-to-follow-isp",level:3},{value:"Situations Where might Violate ISP",id:"situations-where-might-violate-isp",level:3},{value:"How ISP Relates to Other SOLID Principles",id:"how-isp-relates-to-other-solid-principles",level:3},{value:"Dependency Inversion Principle (DIP)",id:"dependency-inversion-principle-dip",level:2},{value:"Concepts",id:"concepts",level:3},{value:"Understanding Dependency Inversion Principle with Example",id:"understanding-dependency-inversion-principle-with-example",level:3},{value:"Refactoring to Follow DIP",id:"refactoring-to-follow-dip",level:3},{value:"Real-World Examples",id:"real-world-examples",level:3},{value:"How DIP Relates to Other SOLID Principles",id:"how-dip-relates-to-other-solid-principles",level:3}];function d(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"solid",children:"SOLID"})}),"\n",(0,t.jsx)(n.p,{children:"Guide for helping developers create better-structured, more manageable object-oriented programming (OOP) code."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"S -- Single Responsibility Principle (SRP)"})," a class should have only one reason to change."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"O -- The Open/Closed Principle (OCP)"})," a class or method open for extension but closed for modification"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"L -- The Liskov Substitution Principle (LSP)"})," objects of a subclass should be able to replace objects of the superclass without affecting the correctness of the program"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"I -- The Interface Segregation Principle (ISP)"})," concrete classes should not be forced to depend on interfaces they do not use."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"D -- The Dependency Inversion Principle (DIP)"})," high-level modules should not depend on low-level modules. Both should depend on abstractions. It helps create loosely coupled code by relying on abstractions rather than concrete implementations."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"single-responsibility-principle-srp",children:"Single Responsibility Principle (SRP)"}),"\n",(0,t.jsx)(n.p,{children:"Every software component should have only one and one job or responsibility."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["A ",(0,t.jsx)(n.strong,{children:"class"})," should be responsible for one specific task."]}),"\n",(0,t.jsxs)(n.li,{children:["A ",(0,t.jsx)(n.strong,{children:"function/method"})," should perform one specific action."]}),"\n",(0,t.jsxs)(n.li,{children:["A ",(0,t.jsx)(n.strong,{children:"module"})," should handle one specific area of functionality."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"cohesion",children:"Cohesion"}),"\n",(0,t.jsx)(n.p,{children:"Cohesion refers to how closely related and focused the responsibilities of a single module, class, or function are. Highly cohesive means that the elements within a module or class are strongly related and work together to achieve a single purpose. Low cohesion a class has unrelated responsibilities bundled together, which makes it harder to maintain and understand.."}),"\n",(0,t.jsx)(n.p,{children:"Low cohesion example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"using System;\n\npublic class UserManager\n{\n    public void addUser(string user)\n    {\n        // Logic to add a user\n    }\n\n    public void deleteUser(string user)\n    {\n        // Logic to delete a user\n    }\n\n    public void writeToFile(string data)\n    {\n        // Logic to write data to a file\n    }\n\n    public string readFromFile(string fileName)\n    {\n        // Logic to read data from a file\n        return fileName;\n    }\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Increasing Cohesion: Splitting Responsibilities into Separate Classes"}),"\nTo improve cohesion and follow the SRP, we can split this class into smaller, more focused classes. One class will handle user management, and another will take care of file operations."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"public class UserManager\n{\n    public void addUser(string user)\n    {\n        // Logic to add a user\n    }\n\n    public void deleteUser(string user)\n    {\n        // Logic to delete a user\n    }\n}\n\npublic class FileManager\n{\n    public void writeToFile(string data)\n    {\n        // Logic to write data to a file\n    }\n\n    public string readFromFile(string fileName)\n    {\n        // Logic to read data from a file\n        return fileName;\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"coupling",children:"Coupling"}),"\n",(0,t.jsx)(n.p,{children:"How closely connected different modules, classes, or methods are to each other."}),"\n",(0,t.jsxs)(n.p,{children:["We aim for ",(0,t.jsx)(n.strong,{children:"low coupling"}),", meaning that classes and components should be as independent from each other as possible."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"High coupling"}),", on the other hand, means that classes are tightly dependent on one another, making it harder to change or reuse parts of the system."]}),"\n",(0,t.jsx)(n.h4,{id:"high-coupling-in-code-one-class-doing-too-much",children:"High Coupling in Code: One Class Doing Too Much"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'using System;\n\npublic class Student {\n    private string studentId;\n\n    public string getStudentId() {\n        return studentId;\n    }\n\n    public void setStudentId(string studentId) {\n        this.studentId = studentId;\n    }\n\n    public void save() {\n        // Database logic directly in the Student class\n        Console.WriteLine("Connecting to database...");\n        Console.WriteLine("Saving student with ID: " + studentId);\n        // Other complex database code here\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h4,{id:"reducing-coupling-separate-database-logic-from-student-class",children:"Reducing Coupling: Separate Database Logic from Student Class"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'using System;\n\npublic class DatabaseManager {\n    public void SaveToDatabase(string studentId) {\n        // Logic for interacting with the database\n        Console.WriteLine("Connecting to database...");\n        Console.WriteLine("Saving student with ID: " + studentId);\n        // Actual database save logic here\n    }\n}\n\npublic class Student {\n    private string studentId;\n    private DatabaseManager dbManager;  // Dependency on DatabaseManager\n\n    public Student(DatabaseManager dbManager) {\n        this.dbManager = dbManager;\n    }\n\n    public string GetStudentId() {\n        return studentId;\n    }\n\n    public void SetStudentId(string studentId) {\n        this.studentId = studentId;\n    }\n\n    public void Save() {\n        // Delegate database operations to the DatabaseManager\n        dbManager.SaveToDatabase(studentId);\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"separation-of-concerns",children:"Separation of Concerns"}),"\n",(0,t.jsx)(n.p,{children:"SoC is a design principle for separating a computer program into distinct sections, such that each section addresses a separate concern. A concern is a set of information that affects the code of a computer program."}),"\n",(0,t.jsx)(n.h4,{id:"example-of-separation-of-concerns",children:"Example of Separation of Concerns"}),"\n",(0,t.jsx)(n.p,{children:"build a simple web application to handle user registration. We'll separate the concerns into different modules:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Database operations"}),"\n",(0,t.jsx)(n.li,{children:"Business logic"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"1. Database Operations:"}),"\nFor interacting with the database. It includes functions for adding and retrieving users from the database."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'using System;\nusing System.Data.SQLite;\n\npublic class Database\n{\n    private SQLiteConnection connection;\n\n    public Database(string dbName)\n    {\n        connection = new SQLiteConnection($"Data Source={dbName};Version=3;");\n        connection.Open();\n        create_table();\n    }\n\n    private void create_table()\n    {\n        string query = @"CREATE TABLE IF NOT EXISTS users (\n                            id INTEGER PRIMARY KEY AUTOINCREMENT,\n                            username TEXT NOT NULL,\n                            email TEXT NOT NULL)";\n        using (var command = new SQLiteCommand(query, connection))\n        {\n            command.ExecuteNonQuery();\n        }\n    }\n\n    public void add_user(string username, string email)\n    {\n        string query = "INSERT INTO users (username, email) VALUES (@username, @email)";\n        using (var command = new SQLiteCommand(query, connection))\n        {\n            command.Parameters.AddWithValue("@username", username);\n            command.Parameters.AddWithValue("@email", email);\n            command.ExecuteNonQuery();\n        }\n    }\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"2. Business Logic:"}),"\nOr user registration, including validation of usernames and emails. It uses the database operations module to interact with the database."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"using System;\npublic class UserService {\n    private Database db;\n\n    public UserService(Database db) {\n        this.db = db;\n    }\n\n    public void register_user(string username, string email) {\n        // Register user here.\n    }\n\n    public bool is_valid_username(string username) {\n        // Check if username is valid\n        return true; // Placeholder\n    }\n\n    public bool is_valid_email(string email) {\n        // Check if email is valid\n        return true; // Placeholder\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"single-responsibility-principle-srp-vs-coupling",children:"Single Responsibility Principle (SRP) vs. Coupling"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"SRP"})," Focuses on ensuring that a class has only one reason to change."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Coupling"})," Focuses on minimizing dependencies between classes or modules."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Relationship"}),": Applying SRP can lead to lower coupling because when each class has a single responsibility, classes are less likely to depend heavily on each other."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"single-responsibility-principle-srp-vs-cohesion",children:"Single Responsibility Principle (SRP) vs. Cohesion"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"SRP"})," Ensures that a class has a single responsibility."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Cohesion"})," Ensures that the tasks performed by a class are closely related."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Relationship"}),": High cohesion often results from applying SRP because a class with a single responsibility will naturally have related tasks grouped together."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"single-responsibility-principle-vs-separation-of-concerns-soc",children:"Single Responsibility Principle vs. Separation of Concerns (SoC)"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"SRP"})," Focuses on single responsibility within a class or module."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"SoC"})," Focuses on dividing the program into distinct features with minimal overlap."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Relationship"}),": Applying SRP is a way to achieve SoC. By ensuring that each class has a single responsibility, the overall design adheres to the principle of separating concerns."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"the-openclosed-principle-ocp",children:"The Open/Closed Principle (OCP)"}),"\n",(0,t.jsx)(n.p,{children:"Software entities (such as classes, modules, and functions) should be open for extension, but closed for modification."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Closed for modification"}),": Once a class is developed and tested, its source code should not be changed in the future to add new behavior. By keeping the core code unchanged, you ensure that the tested and stable parts of the system remain reliable. If every change required modifying the existing code, you could introduce new bugs or break the functionality that has already been proven to work."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Open for extension"}),": can add new functionality to the system without modifying the existing code. This is typically achieved through techniques like ",(0,t.jsx)(n.strong,{children:"inheritance"}),", ",(0,t.jsx)(n.strong,{children:"interfaces"}),", or ",(0,t.jsx)(n.strong,{children:"polymorphism"}),", which allow you to extend the behavior of the code by adding new components (like subclasses or new methods) rather than modifying what\u2019s already in place. This keeps the system flexible and adaptable while preserving the integrity of the original code."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"code-without-ocp",children:"Code without OCP"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'using System;\n\npublic class Invoice\n{\n    private double amount;\n\n    public Invoice(double amount)\n    {\n        this.amount = amount;\n    }\n\n    public double getAmount()\n    {\n        return amount;\n    }\n\n    // This method handles generating basic invoices\n    public void generateInvoice()\n    {\n        Console.WriteLine("Generating basic invoice for amount: " + amount);\n    }\n\n    // This method handles applying discounts on the invoice\n    public void applyDiscount()\n    {\n        Console.WriteLine("Applying discount on invoice: " + amount);\n    }\n}\n\n// Example usage\nclass Program\n{\n    static void Main(string[] args)\n    {\n        Invoice invoice = new Invoice(100);\n        invoice.generateInvoice();\n        invoice.applyDiscount();\n    }\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["If we need to add a new type of invoice later (like an ",(0,t.jsx)(n.strong,{children:"international"})," invoice), we would have to modify this class. Without applying the Open/Closed Principle, we\u2019ll have to modify the existing:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'// Adding new logic for international invoices\npublic void generateInvoice(string type) {\n    if (type == "basic") {\n        Console.WriteLine("Generating basic invoice for amount: " + amount);\n    } else if (type == "international") {\n        Console.WriteLine("Generating international invoice for amount: " + amount);\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"refactoring-the-code-to-follow-ocp",children:(0,t.jsx)(n.strong,{children:"Refactoring the Code to Follow OCP"})}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"we\u2019ll create an interface for generating invoices"}),"\n",(0,t.jsx)(n.li,{children:"create separate classes for each type of invoice"}),"\n",(0,t.jsxs)(n.li,{children:["and we modify the Invoice class to delegate invoice generation to an object of type ",(0,t.jsx)(n.strong,{children:"InvoiceGenerator"})]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'using System;\n\n// 1. Interface for invoice generation\npublic interface InvoiceGenerator {\n    void generateInvoice(double amount);\n}\n\n// 2. Class for generating basic invoices\npublic class BasicInvoice : InvoiceGenerator {\n    public void generateInvoice(double amount) {\n        Console.WriteLine("Generating basic invoice for amount: " + amount);\n    }\n}\n\n// Class for generating international invoices\npublic class InternationalInvoice : InvoiceGenerator {\n    public void generateInvoice(double amount) {\n        Console.WriteLine("Generating international invoice for amount: " + amount);\n    }\n}\n\n// 3. Modified Invoice class\npublic class Invoice {\n    private double amount;\n    private InvoiceGenerator invoiceGenerator;\n\n    // Constructor takes an InvoiceGenerator to delegate invoice generation\n    public Invoice(double amount, InvoiceGenerator invoiceGenerator) {\n        this.amount = amount;\n        this.invoiceGenerator = invoiceGenerator;\n    }\n\n    // Delegate invoice generation to the InvoiceGenerator\n    public void GenerateInvoice() {\n        invoiceGenerator.GenerateInvoice(amount);\n    }\n\n    public void ApplyDiscount() {\n        Console.WriteLine("Applying discount on invoice: " + amount);\n    }\n}\n\n'})}),"\n",(0,t.jsx)(n.p,{children:"additionally, we can add new types of invoices by creating new classes that implement the InvoiceGenerator interface."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'public interface InvoiceGenerator {\n    void generateInvoice(double amount);\n}\n\n// New class for generating detailed invoices\npublic class DetailedInvoice : InvoiceGenerator {\n    public void generateInvoice(double amount) {\n        Console.WriteLine("Generating detailed invoice with breakdown for amount: " + amount);\n    }\n}\n\n'})}),"\n",(0,t.jsx)(n.h3,{id:"caution-when-applying-ocp",children:"Caution When Applying OCP"}),"\n",(0,t.jsx)(n.p,{children:"While the Open/Closed Principle is highly beneficial, it\u2019s important to approach its application with caution to avoid unnecessary complexity."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Over-engineering"}),": Avoid creating too many abstractions or interfaces for every small change. This can lead to a complex codebase that is hard to understand and maintain."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Start Simple"}),": Begin with a straightforward design and only introduce abstractions when there is a clear need for extension."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Balance Between Flexibility and Simplicity"}),": Make sure the system doesn\u2019t become unnecessarily abstract, especially when the future requirements are not clear."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Think About Actual Needs"}),": When applying OCP, always think about real-world needs. Designing code for possible future extensions that may never happen can lead to wasted effort and complexity. Focus on the current requirements, and refactor for extensibility when new demands arise."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"the-liskov-substitution-principle-lsp",children:"The Liskov Substitution Principle (LSP)"}),"\n",(0,t.jsx)(n.p,{children:"Objects of a superclass should be replaceable with objects of a subclass without affecting the correctness of the program."}),"\n",(0,t.jsx)(n.h3,{id:"example-violates-lsp",children:"Example Violates LSP"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Car"})," vs ",(0,t.jsx)(n.strong,{children:"ElectricCar"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'using System;\n\npublic class Car {\n    public void start() {\n        Console.WriteLine("Car is starting");\n    }\n\n    public void stop() {\n        Console.WriteLine("Car is stopping");\n    }\n\n    public virtual void refuel() {\n        Console.WriteLine("Car is refueling");\n    }\n}\n\npublic class ElectricCar : Car {\n    public override void refuel() {\n        // Electric cars don\'t use fuel, so what do we do here?\n        throw new NotSupportedException("Electric cars don\'t need refueling");\n    }\n\n    public void reCharge() {\n        Console.WriteLine("Car is recharging");\n    }\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"the ElectricCar class overrides the refuel() method from the Car class, but it cannot implement the functionality properly because electric cars don\u2019t use fuel. This leads to an issue where calling the refuel() method on an ElectricCar will break the program by throwing an exception."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"class Program {\n    static void Main(string[] args) {\n        // Creating an instance of Car\n        Car myCar = new Car();\n        myCar.Start();\n        myCar.Refuel();  // This works fine as expected for a regular car\n        myCar.Stop();\n\n        // Creating an instance of ElectricCar\n        Car myElectricCar = new ElectricCar();  // We are treating ElectricCar as a Car\n        myElectricCar.Start();\n\n        // Here's the problem:\n        // When we call the refuel() method, it throws an exception\n        // because ElectricCar doesn't need refueling\n        try {\n            myElectricCar.Refuel();  // This will throw a NotSupportedException\n        } catch (NotSupportedException ex) {\n            Console.WriteLine(ex.Message);\n        }\n\n        myElectricCar.Stop();  // This works, but refuel() breaks the program\n    }\n}\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"refactoring-to-follow-lsp",children:"Refactoring to Follow LSP"}),"\n",(0,t.jsx)(n.p,{children:"Create hierarchy that properly represents the relationship between different types of vehicles."}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["Create a general ",(0,t.jsx)(n.strong,{children:"Vehicle"})," class that includes common behaviors like start and stop."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'using System;\npublic abstract class Vehicle {\n    public void start() {\n        Console.WriteLine("Vehicle is starting");\n    }\n\n    public void stop() {\n        Console.WriteLine("Vehicle is stopping");\n    }\n\n    // Abstract method for fuel/energy behavior\n    public abstract void refuel();\n}\n'})}),"\n",(0,t.jsxs)(n.ol,{start:"2",children:["\n",(0,t.jsx)(n.li,{children:"Refactor Car and ElectricCar Classes"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'public class Car : Vehicle {\n    public override void refuel() {\n        Console.WriteLine("Car is refueling");\n    }\n}\n\npublic class ElectricCar : Vehicle {\n    public override void refuel() {\n        // Call recharge() instead of refueling with gasoline\n        recharge();\n    }\n\n    // Electric cars need to recharge instead of refuel\n    private void recharge() {\n        Console.WriteLine("Electric car is recharging");\n    }\n}\n\n// Main class to test the hierarchy\npublic class Solution {\n    public static void Main(string[] args) {\n        // Using Car object\n        Vehicle myCar = new Car();\n        myCar.Start();\n        myCar.Refuel();  // Car-specific refueling behavior\n        myCar.Stop();\n\n        Console.WriteLine();\n\n        // Using ElectricCar object\n        Vehicle myElectricCar = new ElectricCar();\n        myElectricCar.Start();\n        myElectricCar.Refuel();  // Calls Recharge() via Refuel()\n        myElectricCar.Stop();\n    }\n}\n'})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Both ",(0,t.jsx)(n.code,{children:"Car"})," and ",(0,t.jsx)(n.code,{children:"ElectricCar"})," inherit from ",(0,t.jsx)(n.code,{children:"Vehicle"}),", and they can be used interchangeably without breaking the program."]}),"\n",(0,t.jsxs)(n.li,{children:["Each subclass (",(0,t.jsx)(n.code,{children:"Car"})," and ",(0,t.jsx)(n.code,{children:"ElectricCar"}),") implements its own version of the ",(0,t.jsx)(n.code,{children:"refuel()"})," method. For the electric car, ",(0,t.jsx)(n.code,{children:"refuel()"})," calls the specific recharge() method, maintaining expected behavior without breaking the contract of the Vehicle class."]}),"\n",(0,t.jsxs)(n.li,{children:["This ensures that the ",(0,t.jsx)(n.strong,{children:"Liskov Substitution Principle"})," is followed: an instance of ",(0,t.jsx)(n.code,{children:"ElectricCar"})," can replace ",(0,t.jsx)(n.code,{children:"Car"})," without causing issues."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"composition",children:"Composition"}),"\n",(0,t.jsxs)(n.p,{children:['"w"e explored how using inheritance can sometimes violate the Liskov Substitution Principle. Another way to follow LSP without falling into the pitfalls of inheritance is by using ',(0,t.jsx)(n.strong,{children:"composition over inheritance"}),"."]}),"\n",(0,t.jsx)(n.h4,{id:"problem-with-inheritance-violating-lsp",children:"Problem with Inheritance (Violating LSP)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'using System;\n\npublic class Bird {\n    public virtual void fly() {\n        Console.WriteLine("Bird is flying");\n    }\n}\n\npublic class Penguin : Bird {\n    public override void fly() {\n        // Penguins can\'t fly, so this breaks the substitution\n        throw new NotSupportedException("Penguins can\'t fly");\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h4,{id:"using-composition-to-follow-lsp",children:"Using Composition to Follow LSP"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'using System;\n// Interface for flying behavior\npublic interface Flyable\n{\n    void fly();\n}\n\n// Bird class that contains general behavior for all birds\npublic class Bird {\n    public void eat() {\n        Console.WriteLine("Bird is eating");\n    }\n}\n\n// Class for flying birds that uses the Flyable interface\npublic class Sparrow : Bird, Flyable {\n    public void fly() {\n        Console.WriteLine("Sparrow is flying");\n    }\n}\n\n// Class for non-flying birds like Penguin\npublic class Penguin : Bird {\n    // Penguins do not implement Flyable, so no fly() method is needed\n}\n\nclass Main {\n    public static void Main(string[] args) {\n        // Creating a Sparrow that can fly\n        Sparrow mySparrow = new Sparrow();\n        mySparrow.Eat();\n        mySparrow.Fly();  // Works because sparrows can fly\n\n        // Creating a Penguin that cannot fly\n        Penguin myPenguin = new Penguin();\n        myPenguin.Eat();\n        // myPenguin.Fly();  // This will not compile, because Penguins don\'t have a fly() method\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"the-interface-segregation-principle-isp",children:"The Interface Segregation Principle (ISP)"}),"\n",(0,t.jsx)(n.p,{children:"Clients should not be forced to depend on interfaces they do not use, a class should only implement the methods it actually needs."}),"\n",(0,t.jsx)(n.h3,{id:"example-violates-isp",children:"Example Violates ISP"}),"\n",(0,t.jsxs)(n.p,{children:["Universal ",(0,t.jsx)(n.em,{children:"Printer"})," Interface but we implement basic printer that only prints."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'using System;\n\n\npublic interface Printer\n{\n    // Method to print a document\n    void printDocument(string document);\n\n    // Method to scan a document\n    void scanDocument(string document);\n\n    // Method to fax a document\n    void faxDocument(string document);\n\n    // Method to staple a document\n    void stapleDocument(string document);\n}\n\n\npublic class BasicPrinter : Printer\n{\n    public override void printDocument(string document)\n    {\n        Console.WriteLine("Printing document: " + document);\n    }\n\n    public override void scanDocument(string document)\n    {\n        // This printer can\'t scan, so we throw an exception\n        throw new NotSupportedException("Basic printer can\'t scan documents.");\n    }\n\n    public override void faxDocument(string document)\n    {\n        // This printer can\'t fax, so we throw an exception\n        throw new NotSupportedException("Basic printer can\'t fax documents.");\n    }\n\n    public override void stapleDocument(string document)\n    {\n        // This printer can\'t staple, so we throw an exception\n        throw new NotSupportedException("Basic printer can\'t staple documents.");\n    }\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.strong,{children:"BasicPrinter"})," class is forced to implement methods it doesn\u2019t need, such as ",(0,t.jsx)(n.code,{children:"scanDocument()"}),", ",(0,t.jsx)(n.code,{children:"faxDocument()"}),", and ",(0,t.jsx)(n.code,{children:"stapleDocument()"}),". Since it can\u2019t perform these actions, we end up throwing exceptions."]}),"\n",(0,t.jsx)(n.h3,{id:"refactoring-to-follow-isp",children:"Refactoring to Follow ISP"}),"\n",(0,t.jsx)(n.p,{children:"Break the Large Interface into Smaller Interfaces"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'using System;\n\n// Interface for basic printing functionality\npublic interface Printer\n{\n    void printDocument(string document);\n}\n\n// Interface for scanning functionality\npublic interface Scanner\n{\n    void scanDocument(string document);\n}\n\n// Interface for faxing functionality\npublic interface Fax\n{\n    void faxDocument(string document);\n}\n\n// Interface for stapling functionality\npublic interface Stapler\n{\n    void stapleDocument(string document);\n}\n\n\npublic class BasicPrinter : Printer\n{\n    public void printDocument(string document)\n    {\n        System.Console.WriteLine("Printing document: " + document);\n    }\n}\n\npublic class AdvancedPrinter : Printer, Scanner, Fax, Stapler\n{\n    public void printDocument(string document)\n    {\n        System.Console.WriteLine("Printing document: " + document);\n    }\n\n    public void scanDocument(string document)\n    {\n        System.Console.WriteLine("Scanning document: " + document);\n    }\n\n    public void faxDocument(string document)\n    {\n        System.Console.WriteLine("Faxing document: " + document);\n    }\n\n    public void stapleDocument(string document)\n    {\n        System.Console.WriteLine("Stapling document: " + document);\n    }\n}\n\n// Main class to test the new design\npublic class Solution\n{\n    public static void Main(string[] args)\n    {\n        // Testing BasicPrinter (only supports printing)\n        Printer basicPrinter = new BasicPrinter();\n        basicPrinter.printDocument("Basic Document");\n\n        // Testing AdvancedPrinter (supports all functions)\n        AdvancedPrinter advancedPrinter = new AdvancedPrinter();\n        advancedPrinter.printDocument("Advanced Document");\n        advancedPrinter.scanDocument("Advanced Document");\n        advancedPrinter.faxDocument("Advanced Document");\n        advancedPrinter.stapleDocument("Advanced Document");\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"situations-where-might-violate-isp",children:"Situations Where might Violate ISP"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"1. Low Cohesion"}),": happens when a class tries to handle multiple unrelated tasks, making the class less focused and harder to maintain. Low cohesion often leads to ISP violations because the class implements more methods than necessary. Here, ",(0,t.jsx)(n.strong,{children:"MediaDevice"})," tries to handle both playing and recording, which can create low cohesion for a device that only plays media but doesn\u2019t record."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"// MediaDevice interface with methods for audio and video functionalities\npublic interface MediaDevice\n{\n    void playAudio();\n    void playVideo();\n    void recordVideo();\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"2. Fat Interface"}),": contains too many methods, usually covering multiple unrelated functionalities. Fat interfaces force classes to depend on methods they don\u2019t need, leading to bloated code and ISP violations."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Example: Payment Interface"}),"\nThis interface is too large and covers different types of payment methods. It forces all classes implementing it to handle multiple payment options, even if they don\u2019t need them."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"// PaymentProcessor interface with methods for different payment types\npublic interface PaymentProcessor\n{\n    void processCreditCard();\n    void processPayPal();\n    void processBankTransfer();\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"3. Empty or Unsupported Methods"}),": When classes implement an interface and include empty or unsupported methods, it\u2019s a clear sign of an ISP violation."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'using System;\n\npublic class Car : Vehicle\n{\n    public void drive()\n    {\n        Console.WriteLine("Car is driving...");\n    }\n\n    public void fly()\n    {\n        // Cars can\'t fly\n        throw new NotSupportedException("Car can\'t fly");\n    }\n\n    public void sail()\n    {\n        // Cars can\'t sail\n        throw new NotSupportedException("Car can\'t sail");\n    }\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"** 4. Class with too many responsibilities**: It often implements multiple methods from a large interface. This indicates that the interface may need to be broken into smaller ones. Example Employee interface."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'using System;\n\npublic class CustomerSupport : Employee\n{\n    public void calculateSalary()\n    {\n        // Customer support doesn\'t calculate salaries\n        throw new NotSupportedException("Customer support doesn\'t calculate salaries");\n    }\n\n    public void handleCustomerQueries()\n    {\n        Console.WriteLine("Handling customer queries...");\n    }\n\n    public void manageTeam()\n    {\n        // Customer support doesn\'t manage teams\n        throw new NotSupportedException("Customer support doesn\'t manage teams");\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"how-isp-relates-to-other-solid-principles",children:"How ISP Relates to Other SOLID Principles"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"SRP: ISP supports SRP by keeping interfaces focused on a single responsibility, ensuring that classes implement only what they need."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"OCP: ISP aligns with OCP by making it easy to extend systems with new interfaces without modifying existing ones."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"LSP: ISP helps with LSP because classes implementing smaller interfaces respect their contract, making substitution safer and more predictable."}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"dependency-inversion-principle-dip",children:"Dependency Inversion Principle (DIP)"}),"\n",(0,t.jsx)(n.p,{children:"High-level modules should not depend on low-level modules. Both should depend on abstractions."}),"\n",(0,t.jsx)(n.p,{children:"Abstractions should not depend on details; details should depend on abstractions."}),"\n",(0,t.jsx)(n.p,{children:"means that software design should prioritize flexibility and decoupling by ensuring that high-level policies are not directly tied to low-level implementation details. Both high-level and low-level modules should rely on abstractions (e.g., interfaces or abstract classes) to establish a flexible relationship."}),"\n",(0,t.jsx)(n.h3,{id:"concepts",children:"Concepts"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"High-Level Modules"}),": These are components that contain the core business logic of the application. They should dictate the flow of the application without being dependent on specific implementation details."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Low-Level Modules"}),": These modules handle specific, detailed tasks, such as database operations or network communication. They should not directly control the application's main flow."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Abstractions"}),": Interfaces or abstract classes that define general behaviors. High-level and low-level modules depend on these abstractions to communicate, keeping the system loosely coupled."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"understanding-dependency-inversion-principle-with-example",children:"Understanding Dependency Inversion Principle with Example"}),"\n",(0,t.jsxs)(n.p,{children:["Like ",(0,t.jsx)(n.code,{children:"EmailService"})," sends notifications. Without DIP, the high-level module (e.g., ",(0,t.jsx)(n.code,{children:"NotificationService"}),") would depend directly on the low-level ",(0,t.jsx)(n.code,{children:"EmailService"}),". This makes it difficult to switch to other notification types, such as SMS or push notifications, without modifying the ",(0,t.jsx)(n.code,{children:"NotificationService"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'public class EmailService\n{\n    public void sendEmail(string message)\n    {\n        System.Console.WriteLine("Sending email: " + message);\n    }\n}\n\npublic class NotificationService\n{\n    private EmailService emailService;\n\n    public NotificationService()\n    {\n        emailService = new EmailService(); // Tight coupling to EmailService\n    }\n\n    public void send(string message)\n    {\n        emailService.sendEmail(message);\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"refactoring-to-follow-dip",children:"Refactoring to Follow DIP"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["Introduce an Abstraction with interface, ",(0,t.jsx)(n.code,{children:"NotificationSender"})]}),"\n",(0,t.jsxs)(n.li,{children:["Implement Low-Level Modules Based on the Abstraction, ",(0,t.jsx)(n.code,{children:"EmailService"}),", ",(0,t.jsx)(n.code,{children:"SMSService"})," that depend on the ",(0,t.jsx)(n.code,{children:"NotificationSender"})," interface."]}),"\n",(0,t.jsxs)(n.li,{children:["Modify the High-Level Module to Depend on the Abstraction, refactor the ",(0,t.jsx)(n.code,{children:"NotificationService"})," to depend on the ",(0,t.jsx)(n.code,{children:"NotificationSender"})]}),"\n"]}),"\n",(0,t.jsx)(n.mermaid,{value:"flowchart LR\n   NotificationService -- Depend on --\x3e NotificationSender <-- Depend on --\x3e EmailService "}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'// 1. Abstraction for sending notifications\npublic interface NotificationSender\n{\n    void send(string message);\n}\n\n\n//2. EmailService that implements NotificationSender\npublic class EmailService : NotificationSender\n{\n    public void send(string message)\n    {\n        System.Console.WriteLine("Sending email: " + message);\n    }\n}\n\n//2. SMSService that implements NotificationSender\npublic class SMSService : NotificationSender\n{\n    public void send(string message)\n    {\n        System.Console.WriteLine("Sending SMS: " + message);\n    }\n}\n\n//3. NotificationService depends on NotificationSender interface\npublic class NotificationService\n{\n    private NotificationSender notificationSender;\n\n    // Constructor takes a NotificationSender, allowing for flexibility\n    public NotificationService(NotificationSender notificationSender)\n    {\n        this.notificationSender = notificationSender;\n    }\n\n    public void send(string message)\n    {\n        notificationSender.send(message);\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"real-world-examples",children:"Real-World Examples"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Dependency Injection (DI)"}),": Frameworks like Spring (Java), Dagger (Java/Kotlin), and ASP.NET Core (C#) implement DIP by allowing high-level modules to depend on abstractions. They manage the creation and injection of low-level dependencies, promoting loose coupling and easier testing. One of the most popular ways to apply DIP. It involves providing the dependencies (i.e., low-level modules) to a class from the outside rather than having the class create its own dependencies. This allows the high-level module to depend on abstractions, making the system more flexible."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'using System;\n\n// Web Application Service\n\n\n// Abstraction for data repository\npublic interface DataRepository\n{\n    void save(string data);\n}\n\n// Low-level implementation for MySQL\npublic class MySQLRepository : DataRepository\n{\n    public void save(string data)\n    {\n        Console.WriteLine("Saving data to MySQL: " + data);\n    }\n}\n\n// Service that uses Dependency Injection\npublic class DataService\n{\n    private DataRepository repository;\n\n    public DataService(DataRepository repository)\n    {\n        this.repository = repository;\n    }\n\n    public void process(string data)\n    {\n        // Business logic\n        repository.save(data);\n    }\n}\n\n// Example usage\npublic class Program\n{\n    public static void Main(string[] args)\n    {\n        DataRepository mysqlRepo = new MySQLRepository();\n        DataService dataService = new DataService(mysqlRepo);\n        dataService.process("Sample Data");\n    }\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["the ",(0,t.jsx)(n.code,{children:"DataService"})," is decoupled from the specific implementation of ",(0,t.jsx)(n.code,{children:"DataRepository"}),". It can easily switch to a different database without modifying the existing code."]}),"\n",(0,t.jsxs)(n.ol,{start:"2",children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Service Locator Pattern"}),": This pattern provides a centralized registry where high-level modules can request instances of low-level services. The service locator abstracts the creation and management of these services, allowing high-level modules to depend on abstractions rather than concrete implementations."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'using System;\nusing System.Collections.Generic;\n\n// Abstraction for Payment Service\ninterface IPaymentService {\n    void ProcessPayment(double amount);\n}\n\n// Implementation for PayPal\nclass PayPalService : IPaymentService {\n    public void ProcessPayment(double amount) {\n        Console.WriteLine($"Processing payment via PayPal: ${amount}");\n    }\n}\n\n// Service Locator to manage services\nclass ServiceLocator {\n    private static Dictionary<string, IPaymentService> services = new Dictionary<string, IPaymentService>();\n\n    public static void RegisterService(string serviceName, IPaymentService service) {\n        services[serviceName] = service;\n    }\n\n    public static IPaymentService GetPaymentService(string serviceName) {\n        return services.ContainsKey(serviceName) ? services[serviceName] : null;\n    }\n}\n\n// High-level class that depends on abstractions\nclass Solution {\n    private ServiceLocator locator;\n\n    public Solution(ServiceLocator locator) {\n        this.locator = locator;\n    }\n\n    public void ProcessPayment(string serviceName, double amount) {\n        var paymentService = ServiceLocator.GetPaymentService(serviceName);\n        paymentService?.ProcessPayment(amount);\n    }\n\n    public static void Main(string[] args) {\n        // Registering PayPalService\n        ServiceLocator.RegisterService("PayPal", new PayPalService());\n\n        // Creating Solution instance\n        var solution = new Solution(new ServiceLocator());\n\n        // Using Solution class to process payments\n        solution.ProcessPayment("PayPal", 100.0);\n    }\n}\n'})}),"\n",(0,t.jsxs)(n.ol,{start:"3",children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Inversion of Control (IoC) Frameworks"}),"\nIoC frameworks such as Spring in Java, or .NET Core in C#, use dependency injection to apply DIP at scale. These frameworks manage the lifecycle and dependencies of objects for you, allowing for loosely coupled architecture."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"public class OrderService\n{\n    private readonly IPaymentService paymentService;\n\n    // Constructor with dependency injection\n    public OrderService(IPaymentService paymentService)\n    {\n        this.paymentService = paymentService;\n    }\n\n    public void placeOrder(double amount)\n    {\n        paymentService.processPayment(amount);\n    }\n}\n\n\n// Register services (IoC) Container setup\nbuilder.Services.AddScoped<IPaymentService, PaymentService>();\nbuilder.Services.AddScoped<IOrderService, OrderService>();\n"})}),"\n",(0,t.jsx)(n.h3,{id:"how-dip-relates-to-other-solid-principles",children:"How DIP Relates to Other SOLID Principles"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Single Responsibility Principle (SRP):"})," DIP supports SRP by decoupling classes and minimizing dependencies. This ensures that each class focuses on one responsibility, while the details are abstracted away."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Open/Closed Principle (OCP):"})," DIP helps achieve OCP by making modules open for extension but closed for modification. High-level modules rely on abstractions, allowing for easy extension by introducing new implementations."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Liskov Substitution Principle (LSP):"})," DIP complements LSP by ensuring that subclasses or implementations adhere to a common interface, making substitutions safe and seamless."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Interface Segregation Principle (ISP):"})," DIP encourages designing smaller, specific interfaces. High-level modules can then depend on minimal abstractions, avoiding fat interfaces and ensuring that each module only uses what it needs."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>a});var s=i(6540);const t={},o=s.createContext(t);function r(e){const n=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);
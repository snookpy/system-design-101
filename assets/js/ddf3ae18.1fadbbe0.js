"use strict";(self.webpackChunksystem_design_101_docs=self.webpackChunksystem_design_101_docs||[]).push([[4075],{3076:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>a,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"concurrency/concurrency","title":"Concurrency","description":"- Multithreading Multithreading is the ability of a central processing unit (CPU) (or a single core in a multi-core processor) to provide multiple threads of execution concurrently, supported by the operating system. A thread is the smallest sequence of programmed instructions that can be managed independently by a scheduler.","source":"@site/docs/concurrency/concurrency.md","sourceDirName":"concurrency","slug":"/concurrency/","permalink":"/system-design-101/docs/concurrency/","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","next":{"title":"Synchronization Constructs","permalink":"/system-design-101/docs/concurrency/synchronization constructs"}}');var s=t(4848),i=t(8453);const a={sidebar_position:1},o="Concurrency",c={},l=[{value:"Blocks of modern concurrency",id:"blocks-of-modern-concurrency",level:2},{value:"Thread Life Cycle with Concurrency",id:"thread-life-cycle-with-concurrency",level:2},{value:"Components of Threads",id:"components-of-threads",level:2},{value:"Types of Threads",id:"types-of-threads",level:2},{value:"Fork/Join Model",id:"forkjoin-model",level:2},{value:"Initial Setup: The Master Thread",id:"initial-setup-the-master-thread",level:3},{value:"Forking: Creating Subtasks",id:"forking-creating-subtasks",level:3},{value:"Concurrent Execution: Working in Parallel",id:"concurrent-execution-working-in-parallel",level:3},{value:"Joining: Combining Results",id:"joining-combining-results",level:3},{value:"Repeat for efficiency",id:"repeat-for-efficiency",level:3},{value:"Example Create Thread in C#",id:"example-create-thread-in-c",level:2},{value:"Critical Section",id:"critical-section",level:2},{value:"Race Condition",id:"race-condition",level:2}];function h(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"concurrency",children:"Concurrency"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Multithreading"})," Multithreading is the ability of a central processing unit (CPU) (or a single core in a multi-core processor) to provide multiple threads of execution concurrently, supported by the operating system. A thread is the smallest sequence of programmed instructions that can be managed independently by a scheduler."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Concurrency"})," is the execution of multiple instruction sequences at the same time. It happens in the operating system when there are several process threads running in parallel. The running process threads always communicate with each other through shared memory or message passing. Concurrency results in sharing of resources, in turn making the system efficient."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"blocks-of-modern-concurrency",children:"Blocks of modern concurrency"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Programs"}),": Set of instructions that perform a specific task when executed by a computer. It is a static entity that remains inactive until executed."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Process"}),": When run or execute a program, it becomes a process. This is the active phase of the program, using memory and other system resources. If a program is an inactive entity stored on a hard drive, a process is its active state when it's executed and begins its operations."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Thread"}),": Threads are parts of a process. A single process might split its task into multiple threads to work faster or more efficiently. While all threads in a process share the same resources, each thread works on its own individual task"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"Program-Process-Thread",src:t(6483).A+"",width:"1080",height:"756"})}),"\n",(0,s.jsx)(n.h2,{id:"thread-life-cycle-with-concurrency",children:"Thread Life Cycle with Concurrency"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"New:"})," This is the phase where a thread is created but hasn\u2019t started running. At this point, the thread is considered not alive."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Runnable:"})," The thread is ready to run and is waiting for the CPU\u2019s attention. Proper management of runnable threads ensures no thread has to wait too long, enabling faster results."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Running:"})," The thread is executing its tasks. This state allows multiple threads to operate simultaneously, reducing overall processing time. The thread can move out of the Running state for various reasons, such as waiting for resources or yielding control to another thread."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Blocked/Waiting:"})," The thread is in a waiting state; it is waiting on other threads to complete their tasks or some external actions."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Terminated:"})," The thread has completed its tasks and exited. Managing this state well is essential for freeing up system resources."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"Thread Life Cycle",src:t(3956).A+"",width:"1080",height:"756"})}),"\n",(0,s.jsx)(n.h2,{id:"components-of-threads",children:"Components of Threads"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Stack Space"}),": Provides temporary data storage for thread operations."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Program Counter"}),": Maintains the current position of the thread within its assigned task."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Register Set"}),": Stores the thread's current working variables and state."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"types-of-threads",children:"Types of Threads"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"User-Level Threads (ULT)"}),":","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Operated and managed at the user level, invisible to the operating system, facilitating faster operations and easier management."}),"\n",(0,s.jsx)(n.li,{children:"However, the entire process can become unresponsive if one thread encounters a blocking issue."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Kernel-Level Threads (KLT)"}),": Managed directly by the operating system, integral for system stability and individual thread recovery without affecting others."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"forkjoin-model",children:"Fork/Join Model"}),"\n",(0,s.jsx)(n.p,{children:"The Fork/Join model is a parallel programming framework that allows tasks to be divided into smaller subtasks (forked) and then combined (joined) to produce a final result."}),"\n",(0,s.jsx)(n.h3,{id:"initial-setup-the-master-thread",children:"Initial Setup: The Master Thread"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The process begins with a single, primary thread - often referred to as the master thread."}),"\n",(0,s.jsx)(n.li,{children:"This master thread runs through the initial part of the program, executing tasks sequentially."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"forking-creating-subtasks",children:"Forking: Creating Subtasks"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:'When the master thread encounters a task that can be parallelized, the master thread "forks" the task into multiple subtasks.'}),"\n",(0,s.jsx)(n.li,{children:"Each of these subtasks takes on a portion of the workload, running concurrently with others."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"concurrent-execution-working-in-parallel",children:"Concurrent Execution: Working in Parallel"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The master thread and the subtasks execute simultaneously."}),"\n",(0,s.jsx)(n.li,{children:"This parallel execution allows for efficient utilization of system resources, as multiple tasks are handled at the same time."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"joining-combining-results",children:"Joining: Combining Results"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:'Once the subtasks complete their execution, they "join" back.'}),"\n",(0,s.jsx)(n.li,{children:'"Joining" involves terminating the subtasks and combining their results back to master thread.'}),"\n",(0,s.jsx)(n.li,{children:"The master thread then continues with the next part, now with the results or effects of the parallel tasks integrated."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"repeat-for-efficiency",children:"Repeat for efficiency"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The Fork/Join cycle can repeated multiple times throughout the program."}),"\n",(0,s.jsx)(n.li,{children:"The master thread can dynamically spawn and terminate threads based on the computational demands, optimizing resource usage."}),"\n"]}),"\n",(0,s.jsx)(n.mermaid,{value:"sequenceDiagram\n    autonumber\n    participant Master\n    participant Subtask1\n    participant Subtask2\n    participant Subtask3\n\n    Note over Master: Master thread starts sequential tasks\n    Master->>Master: Execute sequential task A\n\n    Note over Master,Subtask3: Fork: Split task into subtasks\n    Master->>Subtask1: Start Subtask 1\n    Master->>Subtask2: Start Subtask 2\n    Master->>Subtask3: Start Subtask 3\n\n    Note over Subtask1,Subtask3: Subtasks execute concurrently\n    Subtask1--\x3e>Master: Subtask 1 completes\n    Subtask2--\x3e>Master: Subtask 2 completes\n    Subtask3--\x3e>Master: Subtask 3 completes\n\n    Note over Master: Join: Combine results\n    Master->>Master: Merge results from subtasks\n\n    Master->>Master: Continue sequential tasks / next fork\n\n"}),"\n",(0,s.jsx)(n.h2,{id:"example-create-thread-in-c",children:"Example Create Thread in C#"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cs",children:'using System;\nusing System.Threading;\n\nclass Program\n{\n   static void Work()\n   {\n       Console.WriteLine("Hello from thread");\n   }\n\n   static void Main()\n   {\n       Thread thread = new Thread(Work);\n       thread.Start();\n       \n       // Wait for the thread to complete\n       thread.Join();\n\n       Console.WriteLine("Thread has completed.");\n   }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"critical-section",children:"Critical Section"}),"\n",(0,s.jsx)(n.p,{children:"A critical section is a part of a program that accesses shared resources (like shared data structures or files) and must not be concurrently accessed by more than one thread of execution."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cs",children:'using System;\nusing System.Threading;\nclass Program\n{\n    private static int counter = 0;\n    private static readonly object lockObject = new object();\n\n    static void IncrementCounter()\n    {\n        for (int i = 0; i < 100000; i++)\n        {\n            lock (lockObject) // Entering critical section\n            {\n                counter++;\n            } // Exiting critical section\n        }\n    }\n\n    static void Main()\n    {\n        Thread thread1 = new Thread(IncrementCounter);\n        Thread thread2 = new Thread(IncrementCounter);\n\n        thread1.Start();\n        thread2.Start();\n\n        thread1.Join();\n        thread2.Join();\n\n        Console.WriteLine($"Final Counter Value: {counter}");\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"race-condition",children:"Race Condition"}),"\n",(0,s.jsx)(n.p,{children:"A phenomenon that occurs when multiple threads access shared data and try to change it at the same time. If the access to the shared data is not properly synchronized, it can lead to inconsistent or incorrect results."}),"\n",(0,s.jsx)(n.mermaid,{value:"sequenceDiagram\n    autonumber\n    participant Thread1\n    participant Thread2\n    participant Counter\n\n    Note over Thread1,Thread2: Shared counter = 0\n\n    Thread1->>Counter: Read counter (0)\n    Thread2->>Counter: Read counter (0)\n    Thread1->>Counter: Increment counter -> 1\n    Thread2->>Counter: Increment counter -> 1 (overwrites Thread1)\n    Thread1->>Counter: Write counter = 1\n    Thread2->>Counter: Write counter = 1\n\n    Note over Counter: Race Condition Occurs!<br>Expected 2, but counter = 1"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Thread1 and Thread2 both read the counter at the same time \u2192 both see 0."}),"\n",(0,s.jsx)(n.li,{children:"Both increment their local copy \u2192 both now have 1."}),"\n",(0,s.jsx)(n.li,{children:"Both write back to the shared counter \u2192 last writer wins, overwriting the first."}),"\n",(0,s.jsx)(n.li,{children:"Result \u2192 The counter is 1 instead of 2."}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},3956:(e,n,t)=>{t.d(n,{A:()=>r});const r=t.p+"assets/images/thread_life_cycle-1b134b9afb50d7364b0f9bbb0584873a.gif"},6483:(e,n,t)=>{t.d(n,{A:()=>r});const r=t.p+"assets/images/program_process_thread-0a02eccc9f6b97fd3927176d4a9c8364.gif"},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var r=t(6540);const s={},i=r.createContext(s);function a(e){const n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);
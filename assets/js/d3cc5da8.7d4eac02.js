"use strict";(self.webpackChunksystem_design_101_docs=self.webpackChunksystem_design_101_docs||[]).push([[7714],{240:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>m,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>r,toc:()=>u});const r=JSON.parse('{"id":"messaging system/intro-message-system","title":"Messaging System","description":"Transfer data among services, applications, processes, or servers. Such a system helps decouple different parts of a distributed system, providing asynchronous way of communication messages between Sender and Receiver. So all senders (or producers) and receivers (or consumers) focus on the data/message without worrying about how the mechanism used to share the data.","source":"@site/docs/messaging system/intro-message-system.md","sourceDirName":"messaging system","slug":"/messaging system/intro-message-system","permalink":"/system-design-101/docs/messaging system/intro-message-system","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Synchronization Constructs","permalink":"/system-design-101/docs/async and concurrency/synchronization constructs"},"next":{"title":"Kafka (TODO)","permalink":"/system-design-101/docs/messaging system/kafka"}}');var t=n(4848),a=n(8453);const i={},o="Messaging System",m={},u=[{value:"Queue",id:"queue",level:2},{value:"Publish-subscribe messaging system",id:"publish-subscribe-messaging-system",level:2},{value:"Message Patterns",id:"message-patterns",level:2}];function c(e){const s={h1:"h1",h2:"h2",header:"header",li:"li",mermaid:"mermaid",p:"p",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.header,{children:(0,t.jsx)(s.h1,{id:"messaging-system",children:"Messaging System"})}),"\n",(0,t.jsxs)(s.p,{children:["Transfer data among services, applications, processes, or servers. Such a system helps decouple different parts of a distributed system, providing ",(0,t.jsx)(s.strong,{children:"asynchronous"})," way of communication messages between Sender and Receiver. So all senders (or producers) and receivers (or consumers) focus on the data/message without worrying about how the mechanism used to share the data."]}),"\n",(0,t.jsx)(s.mermaid,{value:'flowchart LR\n    A["Sender"] --\x3e B["Messaging \n        System"]\n    B --\x3e C["Receiver"]\n    style B fill:#FFE0B2'}),"\n",(0,t.jsx)(s.h2,{id:"queue",children:"Queue"}),"\n",(0,t.jsx)(s.p,{children:"Messages are stored sequentially in a queue. Producers push messages to the rear of the queue, and consumers pull messages from the front of the queue (FIFO - First In, First Out)."}),"\n",(0,t.jsx)(s.mermaid,{value:'flowchart LR\n    subgraph messaging_queue["Messaging Queue"]\n        m3["m3"]\n        m2["m2"]\n        m1["m1"]\n        m0["m0"]\n    end\n  P1["Producer 1"] --\x3emessaging_queue --\x3e C1["Consumer 1"]\n  P2["Producer 2"] --\x3emessaging_queue --\x3e C2["Consumer 2"]'}),"\n",(0,t.jsx)(s.p,{children:"A message can be consumed by only one consumer. Once a consumer grabs a message from the queue, it is removed from the queue which the next consumer will get the next message. This limits the system as multiple consumers cannot read the same message."}),"\n",(0,t.jsx)(s.mermaid,{value:'flowchart LR\n    subgraph messaging_queue["Messaging Queue"]\n        m6["m6"]\n        m5["m5"]\n        m4["m4"]\n        m3["m3"]\n    end\n  P1["Producer 1"] --\x3e m7 --\x3e messaging_queue\n  P2["Producer 2"] --\x3e m8 --\x3e messaging_queue\n  messaging_queue --\x3e m0 --\x3e C1["Consumer 1"]\n  messaging_queue --\x3e m1 --\x3e C2["Consumer 2"]\n  messaging_queue --\x3e m2 --\x3e C3["Consumer 3"]'}),"\n",(0,t.jsx)(s.h2,{id:"publish-subscribe-messaging-system",children:"Publish-subscribe messaging system"}),"\n",(0,t.jsxs)(s.p,{children:["In the pub-sub model, messages are divided into topics.\nA publisher (or a producer) sends messages to a specific topic.Subscribers (or consumers) subscribe to a topic to receive messages from the publisher. Unlike the queue system, multiple subscribers can receive the same topic.\nThe messaging system that stores and maintains the messages is commonly known as the message ",(0,t.jsx)(s.strong,{children:"broker"}),". This loose coupling enables subscribers and publishers to read and write messages at different rates."]}),"\n",(0,t.jsx)(s.mermaid,{value:'flowchart LR\n    subgraph pub_sub["Pub Sub (**Broker**) **Topic: Sales**"]\n        m5["m5"]\n        m4["m4"]\n        m3["m3"]\n        m2["m2"]\n    end\n  P1["Publisher 1"] --\x3e m7 --\x3e pub_sub\n  P2["Publisher 2"] --\x3e m8 --\x3e pub_sub\n  pub_sub --\x3e m11["m1"] --\x3e S1["Subscriber 1"]\n  pub_sub --\x3e m12["m1"] --\x3e S2["Subscriber 2"]\n  pub_sub --\x3e m13["m1"] --\x3e S3["Subscriber 3"]'}),"\n",(0,t.jsx)(s.h2,{id:"message-patterns",children:"Message Patterns"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Point-to-point"}),": A message is sent from one producer to one consumer. The message is consumed by only one consumer."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Publish-subscribe"}),": The publish-subscribe pattern delivers each message to all interested subscribers like ",(0,t.jsx)(s.strong,{children:"One-to-Many"}),"."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Fan-out/Fan-in (Scatter-Gather)"}),": A message is sent to multiple consumers. Each consumer receives a copy of the message. And then the responses are aggregated and sent back to the producer."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Request-Reply"}),": A message is sent from a producer to a consumer, and the consumer sends a response back to the producer. This pattern is commonly used in synchronous communication but implements through messaging. Tools Like gRPC are direct request-response(not messaging), but in messaging systems can implement this pattern explicitly."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Dead Letter Queue"}),": A dead-letter queue (DLQ) is a specialized queue that stores messages that cannot be processed successfully by the primary messaging system. When a message fails to be delivered or processed after a certain number of attempts, it is moved to the DLQ for further analysis and troubleshooting. This helps prevent message loss and allows for better error handling in messaging systems."]}),"\n"]})]})}function d(e={}){const{wrapper:s}={...(0,a.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8453:(e,s,n)=>{n.d(s,{R:()=>i,x:()=>o});var r=n(6540);const t={},a=r.createContext(t);function i(e){const s=r.useContext(a);return r.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),r.createElement(a.Provider,{value:s},e.children)}}}]);
"use strict";(self.webpackChunksystem_design_101_docs=self.webpackChunksystem_design_101_docs||[]).push([[1475],{6031:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>l,frontMatter:()=>o,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"security/security","title":"Security","description":"Authentication","source":"@site/docs/security/security.md","sourceDirName":"security","slug":"/security/","permalink":"/system-design-101/docs/security/","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_position":6},"sidebar":"tutorialSidebar","previous":{"title":"Indexes","permalink":"/system-design-101/docs/Indexes"},"next":{"title":"SOLID","permalink":"/system-design-101/docs/OOD/solid"}}');var i=t(4848),r=t(8453);const o={sidebar_position:6},a="Security",c={},d=[{value:"Authentication",id:"authentication",level:2},{value:"Authorization",id:"authorization",level:2},{value:"OAuth",id:"oauth",level:2},{value:"Key Components of OAuth",id:"key-components-of-oauth",level:3},{value:"JWT (JSON Web Token)",id:"jwt-json-web-token",level:2},{value:"Characteristics",id:"characteristics",level:3},{value:"Conclusion",id:"conclusion",level:3},{value:"Proof Key for Code Exchange by OAuth Public Clients (PKCE)",id:"proof-key-for-code-exchange-by-oauth-public-clients-pkce",level:2},{value:"How PKCE Works",id:"how-pkce-works",level:3},{value:"without PKCE",id:"without-pkce",level:3},{value:"Encryption",id:"encryption",level:2},{value:"Cryptography",id:"cryptography",level:2}];function h(e){const n={h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"security",children:"Security"})}),"\n",(0,i.jsx)(n.h2,{id:"authentication",children:"Authentication"}),"\n",(0,i.jsx)(n.p,{children:"the process verifying the identity of a user or system, typically through credentials like usernames and passwords, biometrics, or tokens."}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Single-Factor Authentication (SFA)"}),": Involves one method of verification, such as a password or PIN."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Two-Factor Authentication (2FA)"}),": Requires two different forms of verification, such as a password and a code sent to a mobile device."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Multi-Factor Authentication (MFA)"}),": Involves two or more verification methods, enhancing security by combining something you know (password), something you have (smartphone), and something you are (fingerprint) and maybe a token."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"authorization",children:"Authorization"}),"\n",(0,i.jsx)(n.p,{children:"After authentication, authorization determines what resources and actions the authenticated user or system is permitted to access. Common models include:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Role-Based Access Control (RBAC)"}),": Access is granted based on the user's role within an organization (e.g., admin, user, guest)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Permissions"}),": Access is granted based on specific permissions assigned to users or groups, like read, write, or execute permissions."]}),"\n"]}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Aspect"}),(0,i.jsx)(n.th,{children:"Authentication"}),(0,i.jsx)(n.th,{children:"Authorization"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Definition"})}),(0,i.jsx)(n.td,{children:"The process of verifying who a user is."}),(0,i.jsx)(n.td,{children:"The process of verifying what access a user has."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Focus"})}),(0,i.jsx)(n.td,{children:"Identity verification."}),(0,i.jsx)(n.td,{children:"Access rights and privileges."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Example"})}),(0,i.jsx)(n.td,{children:"Entering a username and password."}),(0,i.jsx)(n.td,{children:"Checking if a user can access a specific resource, like a file or database."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"How It Works"})}),(0,i.jsx)(n.td,{children:"Typically involves passwords, biometrics, OTPs, etc."}),(0,i.jsx)(n.td,{children:"Involves settings, roles, and permissions that define what resources a user can access."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Tools/Methods"})}),(0,i.jsx)(n.td,{children:"Login forms, OTPs, biometric scanners."}),(0,i.jsx)(n.td,{children:"Access control lists, role-based access control."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Order in Process"})}),(0,i.jsx)(n.td,{children:"Comes first in the security process."}),(0,i.jsx)(n.td,{children:"Follows after authentication is successful."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Key Concern"})}),(0,i.jsx)(n.td,{children:"Verifying user identity is genuine."}),(0,i.jsx)(n.td,{children:"Managing user permissions and access levels."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Frequency"})}),(0,i.jsx)(n.td,{children:"Typically occurs once at the beginning of a session."}),(0,i.jsx)(n.td,{children:"Can occur multiple times, whenever a user requests access to a resource."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Dependence"})}),(0,i.jsx)(n.td,{children:"Independent process, can exist without authorization in some systems."}),(0,i.jsx)(n.td,{children:"Requires authentication as a prerequisite."})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"oauth",children:"OAuth"}),"\n",(0,i.jsx)(n.p,{children:"OAuth (Open Authorization) is an open standard for access delegation commonly used to grant websites or applications limited access to user information without exposing passwords."}),"\n",(0,i.jsx)(n.h3,{id:"key-components-of-oauth",children:"Key Components of OAuth"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Delegation"}),": OAuth allows users to delegate access to their resources on one site (the resource server) to another site (the client) without exposing their credentials."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Tokens"}),": OAuth uses access tokens to grant access to resources. These tokens are issued to the client by the authorization server after the user grants permission."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Use Cases"}),": Commonly used for third-party applications to access user data on platforms like Google, Facebook."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"jwt-json-web-token",children:"JWT (JSON Web Token)"}),"\n",(0,i.jsx)(n.p,{children:"Is a token format used in authorization and information exchange. It\u2019s a JSON object encoded as a string, which is digitally signed, and optionally encrypted. After a user logs in, the server creates a JWT with user information, signs it, and sends it back to the client. The client then uses this JWT to access protected resources by sending it with HTTP requests."}),"\n",(0,i.jsx)(n.h3,{id:"characteristics",children:"Characteristics"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Authentication & Information Exchange"}),": JWT can be used for both authentication and secure data exchange."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Structure"}),": A JWT typically consists of three parts: Header, Payload, and Signature."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Stateless"}),": JWTs are self-contained, allowing stateless authentication, and are typically used in RESTful APIs."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Use Cases"}),": Often used for token-based authentication systems."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"conclusion",children:"Conclusion"}),"\n",(0,i.jsx)(n.p,{children:"Both OAuth and JWT are essential components in modern web security, often used together to provide secure."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Complementary Technologies"}),": In many implementations, OAuth uses JWT as the format for its tokens. OAuth manages the authorization process, and JWT provides a secure token format."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Use JWT for"}),": Securely transmitting information between parties and stateless authentication."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Use OAuth for"}),": Delegating access to user data to third-party applications without exposing user credentials."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"proof-key-for-code-exchange-by-oauth-public-clients-pkce",children:"Proof Key for Code Exchange by OAuth Public Clients (PKCE)"}),"\n",(0,i.jsx)(n.p,{children:'PKCE (pronounced "pixy") is an extension to the OAuth 2.0 authorization framework that enhances security for public clients, such as mobile and single-page applications (SPAs), which cannot securely store client secrets. PKCE mitigates the risk of authorization code interception attacks by adding an additional layer of security during the OAuth 2.0 authorization code flow.'}),"\n",(0,i.jsx)(n.h3,{id:"how-pkce-works",children:"How PKCE Works"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Code Challenge and Code Verifier"}),': The client generates a random string called the "code verifier" and derives a "code challenge" from it using a transformation method (usually SHA256).']}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Authorization Request"}),": The client initiates the OAuth 2.0 authorization request, including the code challenge and the method used to derive it."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Authorization Response"}),": The authorization server responds with an authorization code if the user grants permission."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Token Request"}),": The client sends a token request to the authorization server, including the authorization code and the original code verifier."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Token Response"}),": The authorization server verifies the code verifier against the code challenge. If they match, it issues an access token to the client."]}),"\n"]}),"\n",(0,i.jsx)(n.mermaid,{value:"sequenceDiagram\n    participant Browser as SPA (React)\n    participant IdP as Authorization Server\n    participant API as .NET API\n\n    %% Step 1: Code Verifier & Challenge\n    Note over Browser: 1. Generate code_verifier (random string) Derive code_challenge = SHA256(code_verifier)\n\n    Browser->>IdP: 2. Authorization Request (include code_challenge & method)\n    Note over IdP,Browser: User logs in and grants consent\n\n    IdP->>Browser: 3. Authorization Response (authorization code)\n\n    Browser->>IdP: 4. Token Request Send authorization code + original code_verifier\n    Note over IdP: Verify that SHA256(code_verifier) matches code_challenge\n\n    IdP->>Browser: 5. Token Response Access Token + ID Token\n\n    Browser->>API: Call API with Bearer Token\n    API->>Browser: Protected Data\n"}),"\n",(0,i.jsx)(n.h3,{id:"without-pkce",children:"without PKCE"}),"\n",(0,i.jsx)(n.p,{children:"If an attacker sniffs the authorization code during the redirect, they can call the token endpoint and get your tokens (since nothing ties the code to the client)."}),"\n",(0,i.jsx)(n.mermaid,{value:"sequenceDiagram\n    participant Browser as SPA (React)\n    participant IdP as Auth Server\n    participant API as .NET API\n\n    Browser->>IdP: /authorize (client_id, redirect_uri)\n    IdP->>Browser: Redirect with Authorization Code\n    Note over Browser: This code can be intercepted by an attacker\n    Browser->>IdP: /token (code + client_secret)  \u274c\n    IdP->>Browser: Access Token + ID Token\n    Browser->>API: Call with Bearer Token\n    API->>Browser: Protected Data"}),"\n",(0,i.jsx)(n.h2,{id:"encryption",children:"Encryption"}),"\n",(0,i.jsx)(n.p,{children:"Encryption is the process of converting plaintext data into a coded format (ciphertext) to prevent unauthorized access."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Symmetric Encryption"}),": Uses the same key for both encryption and decryption. AES (Advanced Encryption Standard), DES (Data Encryption Standard) are common symmetric algorithms."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Asymmetric Encryption"}),": Uses a pair of keys (public key and private key). The public key encrypts the data, and the private key decrypts it. RSA (Rivest-Shamir-Adleman) and ECC (Elliptic Curve Cryptography) are popular asymmetric algorithms."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"cryptography",children:"Cryptography"}),"\n",(0,i.jsx)(n.p,{children:"Cryptography is the practice of encrypting and decrypting data using mathematical algorithms. It's used for secure communication, data privacy, and authentication."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Hashing"}),": (one-way, fixed-size output)","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Algorithms: SHA-256, SHA-3, MD5, Slow hashing -> bcrypt, scrypt, Argon2."}),"\n",(0,i.jsx)(n.li,{children:"Use Cases: Password storage, data integrity verification."}),"\n",(0,i.jsx)(n.li,{children:"Salting: Adding random data (salt) to input before hashing to prevent attacks like rainbow tables."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Digital Signatures"}),": A cryptographic technique that verifies the authenticity and integrity of a message or document. It uses asymmetric encryption to create a unique signature that can be verified by anyone with the public key. Common digital signature algorithms include RSA and ECDSA."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Message Authentication Codes (MACs)"}),": A short piece of information used to authenticate a message and ensure its integrity. It uses a secret key to generate a unique code that can be verified by the recipient. HMAC (Hash-based Message Authentication Code) is a common MAC algorithm."]}),"\n"]})]})}function l(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var s=t(6540);const i={},r=s.createContext(i);function o(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);